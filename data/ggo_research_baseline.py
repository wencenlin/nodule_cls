# -*- coding: utf-8 -*-
"""GGO_research_baseline.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UOzu2_u7Mw1ukQnqcOZd8ZzEwbSKQvra
"""

import glob, scipy
import numpy as np
import SimpleITK as sitk
import matplotlib.pyplot as plt
from os.path import join
from skimage import measure
from scipy.ndimage.morphology import *
from scipy.ndimage.interpolation import zoom

from time import time
import threading
import queue
import os
from natsort import natsorted


def show(imgs, size_subplot = (5,5), ticks = True):
    '''
    imgs: (nested) list of image(s)
    size_subplot: size of individual subplot
    ticks: show ticks or not
    '''
    while not isinstance(imgs, list) or not isinstance(imgs[0], list):
        imgs = [imgs]
    rows = len(imgs)
    cols = max([len(imgs_col) for imgs_col in imgs])
    for row, imgs_col in enumerate(imgs):
        for col, img in enumerate(imgs_col):
            idx = row * cols + col
            img = ("", img) if isinstance(img, np.ndarray) else img
            plt.subplot(rows, cols, 1 + idx)
            plt.imshow(img[1], "gray")
            plt.title(img[0])
            if not ticks:
                plt.xticks([])
                plt.yticks([])
    plt.gcf().set_size_inches(size_subplot[1]*cols, size_subplot[0]*rows)
    plt.show()

def get_original(folder_dcm, combine_series=False):
    '''
    folder_dcm: folder of series of .dcm
    ---
    img_original: directly concatenated 3d image
    spacing_original: real-world spacing of img_original
    origin_original: real-world origin
    '''
    reader = sitk.ImageSeriesReader()
    if not combine_series:  # one series
        names_dcm = reader.GetGDCMSeriesFileNames(folder_dcm)
    else:  # several series in one folder
        names_dcm = tuple()
        series_ids = reader.GetGDCMSeriesIDs(folder_dcm)
        for series_id in series_ids:
            id_names_dcm = reader.GetGDCMSeriesFileNames(folder_dcm, seriesID=series_id)
            names_dcm = id_names_dcm + names_dcm
    reader.SetFileNames(names_dcm)
    image = reader.Execute()  # xyz
    # xyz to zyx after GetArrayFromImage(), then reverse data along z axis for starting from first dicom in folder
    img_original = sitk.GetArrayFromImage(image)[::-1, :, :].astype("int32")
    spacing_original = np.array([*image.GetSpacing()][::-1])  # xyz to zyx
    origin_original = np.array([*image.GetOrigin()][::-1])  # xyz to zyx
    return img_original, spacing_original, origin_original

def resize_img(img, spacing_original, spacing_ideal = np.ones(3), **params_zoom):
    '''
    img: image to be resized
    spacing_original: original spacing of 'img'
    spacing_ideal: ideal spacing
    '''
    shape_ideal = img.shape * spacing_original / spacing_ideal
    spacing_resized = spacing_original * img.shape / shape_ideal
    img_resized = zoom(img, zoom = shape_ideal.round() / img.shape, **params_zoom)
    return img_resized, spacing_resized

def map_img(img, window = np.array([-1200, 600]), dtype = "uint8"):
    '''
    img: image
    window: original floor and ceiling of the image to be preserved
    dtype: dtype of mapped image
    '''
    info = np.iinfo(dtype)
    img_normalized = (img - min(window)) / (max(window) - min(window))
    img_truncated = np.maximum(np.minimum(img_normalized, 1), 0)
    img_mapped = (img_truncated * (info.max - info.min) + info.min).astype(dtype)
    return img_mapped


#####################################################
class Worker(threading.Thread):
    def __init__(self, queue, job):
        threading.Thread.__init__(self)
        self.queue = queue
        self.job = job

    def run(self):
        while self.queue.qsize() > 0:
            id = self.queue.get()
            self.job(id)


def process(idx, demo=False):
    t0 = time()

    folder_dcm = f"{SearchDcmDir}{idx}/"
    folder_npy = OutputDir

    img_original, spacing_original, origin_original = get_original(folder_dcm)
    img_resized, spacing_resized = resize_img(img_original, spacing_original, )

    if demo:
        show([img_original[img_original.shape[0] // 2],
              img_resized[img_resized.shape[0] // 2]])

        '''
        'img_resized.npy' 如果要當作像是 '.clean.npy' 的 model input，
        需要透過以下轉換來完成維度增加和 intensity mapping：

        _input = map_img(img_resized)[None,:]

        不直接存轉換完的格式是因為，map 後的 info loss 是不可逆的，以後的步驟就不能直接拿來用
        '''
        img_mapped = map_img(img_resized)
        idx_axial = img_resized.shape[0] // 2
        show([("w/o mapping", img_resized[idx_axial]),
              ("mapped", img_mapped[idx_axial])])
    else:
        prefix = join(folder_npy, str(idx))
        # np.save(prefix + "_spacing_original.npy", spacing_original)
        # np.save(prefix + "_spacing_resized.npy", spacing_resized)
        # np.save(prefix + "_origin.npy", origin_original)
        # np.save(prefix + "_img_original.npy", img_original)
        np.save(prefix + "_img_resized.npy", img_resized)

    print(f"\nID {idx}, time elapsed: ", time() - t0)


#####################################################
SearchDcmDir = "D:/data_LungNodule/raw_dicom/"
OutputDir = "D:/data_LungNodule/crop_npy"
# SearchDcmDir = "C:/Users/user/Desktop/Doing/3D/OtherTest/DICOM/"
# OutputDir = "C:/Users/user/Desktop/Doing/3D/OtherTest/NPY/"

#####################################################
# choose one id to process and demo
# id = 136
# # process(id, demo=True)
# process(id)
# exit(0)

#####################################################
# process with thread
thread_num = 10
dirlist = os.listdir(SearchDcmDir)
dirlist = natsorted(dirlist)
# dirlist = [i for i in dirlist if int(i) > 665]
print(dirlist)

t0 = time()

# 建立佇列
id_queue = queue.Queue()
# 將資料放入佇列
for id in dirlist:
    id_queue.put(id)

worker_list = []
for i in range(thread_num):
    worker_list.append(Worker(id_queue, process))
for worker in worker_list:
    # 讓 Worker 開始處理
    worker.start()
for worker in worker_list:
    # 等待所有 Worker 結束
    worker.join()

print("\nTotal Time elapsed: ", time() - t0)
